---
title: "Asteroid Mining Feasibility Analysis"
author: "Shakleen Ishfar, Eugene Ayonga, Selenge Tulga, KT Wirth"
date: "2023-11-14"
output: 
  pdf_document:
    number_sections: true
bibliography: references.bib
csl: ieee.csl
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(dev = "png",
                      dpi = 300,
                      echo = FALSE,
                      cache = TRUE)

library(ggplot2)
library(dplyr)
library(MASS)
library(corrplot)
library(caret)
```

# Introduction

Our modern world relies on natural resources like iron, copper, gold, and nickel, which form the foundation of our civilization. Unfortunately, excessive mining is harming the environment. Looking to the future, space exploration has become more affordable, opening up the possibility of tapping into asteroids for resources.

Asteroids, such as the relatively small metallic ones like Freakazoid, contain billions of dollars' worth of precious metals, even with diameters less than 1,000 meters. On a grander scale, asteroids like 16-Psyche could sustain the world's iron and nickel needs for millions of years.

![An illustration of the solar system showing the two asteroid belts. Image taken from Kurzgesagt](.\images\asteroid-belt.png)

Efficiently mining asteroids requires the development of sustainable and affordable space-grade technology. To achieve this, we must also identify which asteroids to mine and why. This project focuses on addressing the latter part of the challenge. Using statistical methods and techniques, we aim to determine which asteroids can and should be mined. Our inspiration comes from the insightful Kurzgesagt YouTube video titled "Unlimited Resources From Space – Asteroid Mining." [@Kurzgesagt2020]


# Dataset

To carry out this study we use the data pulled from NASA’s Jet Propulsion Laboratory 
(JPL), available in Kaggle. (@OpenAsteroidDataBasu2019)

```{r Loading dataset}
df <- read.csv("Asteroid_Updated.csv")

sprintf("Dataset has %d rows and %d columns", nrow(df), ncol(df))
```

The data set is quite large with nearly 1 million rows of data and 31 different columns. 

## Column Description

Let us first introduce the different attributes relevant for our study. Relevant column names from the dataset are enclosed in paranethesis after the name of the attribute.

### Semi Major Axis (a)

The semi-major axis of an asteroid is the average orbital distance from the Sun. It is half of the major axis, which is the total distance between the closest and farthest points of the asteroid’s orbit, also known as the perihelion (q) and aphelion (ad). The semi-major axis is often measured in astronomical units (AU), with 1 AU defined as the mean Earth-Sun distance. [@NASAOrbitsKeplersLaws2023]

```{r Column_Description semi major axis, echo=F}
print("Distribution of values for semi-major axis")
summary(df$a)
```

### Eccentricity (e)

The eccentricity of an asteroid is a measure of how much its orbit deviates from a perfect circle. Orbital shapes can be defined based on eccentricity value. [@WikipediaOrbitalEccentricity2023]

1. Circular orbit: $e=0$

2. Elliptic orbit: $0 < e < 1$

3. Parabolic trajectory: $e = 1$

4. Hyperbolic trajectory: $e > 1$

```{r Column_Description eccentricity, echo=F}
print("Distribution of values for eccentricity")
summary(df$e)
```

```{r Column_Description Distribution of Orbital shape, echo=F}
define_orbit <- function(e) {
  if (e < 1e-6) {
    return("Circular")
  } else if (0 < e & e < 1) {
    return("Elliptical")
  } else if (e > 1) {
    return("Hyperbolic")
  }
  return("Parabolic")
}

table(sapply(df$e, define_orbit))
```

### Geometric Albedo (albedo)

In astronomy, the geometric albedo of a celestial body is the ratio of its actual brightness as seen from the light source (i.e., at zero phase angle) to that of an idealized flat, fully reflecting, diffusively scattering (Lambertian) disk with the same cross-section. Albedo is measured on a scale of zero to one, zero representing a surface that reflects no light, and one representing an object that reflects all incoming light. [@WikipediaGeometricAlbedo2023]

```{r Column_Description Geometric Albedo, echo=F}
print("Distribution of values for eccentricity")
summary(df$albedo)
```

It is possible to estimate what materials constitute the asteroid from its geometric albedo:

* Low albedo (<0.2) suggests carbonaceous chondrites (C-type asteroids) or dark basaltic asteroids.

* High albedo (>0.2) suggests metallic asteroids (M-type), silicate-rich asteroids (S-type), or icy asteroids.

```{r Column_Description Material Constitution, echo=F}
define_material <- function(albedo) {
  if (albedo < 0.2) {
    return("C Type")
  } 
  return("M or S Type")
}

table(sapply(na.omit(df$albedo), define_material))
```

### Absolute Magnitude Parameter (H)

Stands for absolute magnitude parameter, denotes the brightness of an asteroid. It is defined as the apparent magnitude the asteroid would have if it were observed from the Sun at a distance of 1 Astronomical Unit (AU). This parameter is used in the calculation of an asteroid’s size. The size of an asteroid can be estimated from its absolute magnitude (H) and an assumed geometric albedo. [@NASACNEOSAsteroidSizeEstimator2023]

```{r Column_Description Absolute Magnitude Paramter}
print("Distribution of values for absolute magnitude parameter")
summary(df$H)
```

### Magnitude Slope Parameter (G)

The magnitude slope parameter is a component of the _H-G magnitude_ system developed for predicting the magnitude of an asteroid as a function of solar phase angle. It can also be used for physical studies, by providing a basis for interpolating or extrapolating brightness from the phase angles observed at one apparition to the phase angles observed at another apparition. Thus allowing one to identify the intrinsic difference in brightness from one apparition to another. This is usually necessary for studies of asteroid shapes and pole positions. [@Harris1989]

```{r Column_Description Magnitude Slope Parameter}
print("Distribution of values for magnitude slope parameter")
summary(df$G)
```

### Color filters (ub, bv, ir)

The three different color index magnitude differences for asteroids. Each is the difference in magnitude when observed through two filters.

* UB: Ultra-violet and blue filter.

* BV: Blue and Visible (Green) filter.

* IR: Infra-Red filter.

```{r Column_Description Color filters}
print("Distribution of values for magnitude slope parameter")
summary(df[, c("UB", "BV", "IR")])
```
These color indices are used to characterize the surface properties of the asteroid, as different materials reflect light differently at different wavelengths.

| Color Filter | C-type      | M-type         | S-type        | Measured Component   | Higher Value Indicates    |
| ------------ | ----------- | -------------- | ------------- | ------------- | ------------- |
| UB           | 0.10 - 0.35 | \-0.30 - -0.10 | \-0.05 - 0.15 | Iron                 | More iron content         |
| BV           | 0.70 - 1.10 | 0.40 - 0.60    | 0.60 - 0.80   | Pyroxene and Olivine | More pyroxene and olivine |
| IR           | 0.80 - 1.20 | 0.60 - 0.80    | 0.75 - 1.00   | Water Ice            | More water ice            |

### Orbital Condition Code (condition_code)

Stands for orbital condition code, also known as the U uncertainty parameter. Values range from 0 to 9 on the logarithmic scale indicating how well an object's orbit is known. A value of 0 indicates a well-determined orbit, while a value of 9 indicates that there are insufficient observations for long-term orbit prediction. [@NASATrajectoryBrowserUserGuide2023]

Condition Code | Orbit Longitude runoff
------- | -------
0      | < 1.0 arc seconds
1      | < 4.4 arc seconds
2      | < 19.6 arc seconds
3      | < 1.4 arc minutes
4      | < 6.4 arc minutes
5      | < 28.2 arc minutes
6      | < 2.1 degrees
7      | < 9.2 degrees
8      | < 40.7 degrees
9      | > 40.7 degrees

### Near Earth Objects (NEO)

The value of 1 means the object is near earth, otherwise its 0. There are 4 types of neos. [@NASACNEOSNEOGroups2023]

| Type    | Semi-major Axis (AU) | Aphelion Distance (AU) |
| ------- | -------------------- | ---------------------- |
| Atiras  | < 1.0                | < 0.983                |
| Atens   | < 1.0                | \> 0.983               |
| Apollos | \> 1.0               | < 1.017                |
| Amors   | \> 1.0               | 1.017 - 1.300          |

### Minimum Orbit Intersection Distance (moid)

It is a measure used in astronomy to assess potential close approaches and collision risks between astronomical objects. [@WikipediaMinimumOrbitIntersectionDistance2023]

MOID is important to consider for asteroid mining because:

* A lower MOID indicates a closer approach to Earth, potentially reducing the cost and travel time for mining missions.

* Consider the frequency and duration of close approaches for efficient mission planning.

* Smaller objects may have significantly lower MOIDs, making them more accessible.

# Data Processing

Before moving forward with our analysis, we first need to process the dataset.

## Attribute Selection

The dataset contains 31 columns, all of which we don't need. So, we first select the columns we need and discard the rest.

```{r Attribute_Selection, echo=T}
df <- df[c("a", "e", "moid", "neo", "condition_code", "UB", "BV", "IR", "G", "H",
           "albedo", "diameter")]
sprintf("Number of columns in dataset: %d", ncol(df))
```

The dataset contains many null values across it's columns. We have to fill in the
missing values as well as we can. Let's first see what percentage of the columns
are missing.

```{r Imputation Missing value percentage for each column, echo=T}
missing_percentage <- colMeans(is.na(df)) * 100
sorted_missing <- sort(missing_percentage, decreasing = TRUE)

formatted_missing <- sprintf("%2.6f%%", sorted_missing)

result_df <- data.frame(Column = names(sorted_missing), 
                        MissingPercentage = formatted_missing)
print(result_df)
```

Observations:

* albedo, and diameter have over 80\% of missing values. We can use regression to fill in these values as best as we can.

* H, e, and a has very few missing values. We can impute with mean.

* condition\_code and neo has no missing values.

## Discard

### Columns

As nearly all the values are missing in G, UB, BV, and IR. We'll be dropping these columns and won't be using them in our study.

```{r Discarding Columns, echo=T}
df <- df[c("a", "e", "moid", "neo", "condition_code", "H", "albedo", "diameter")]
sprintf("Number of columns in dataset: %d", ncol(df))
```

### Rows

The column condition code has some values that aren't acceptable. Because we don't know what those values should be, it's easier to just drop them.

```{r Discarding Rows, echo=T}
before <- nrow(df)
acceptable_values <- c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
df <- df %>% filter(condition_code %in% acceptable_values)
sprintf("Dropped %d rows", before - nrow(df))
```

## Imputation

### Impute numerical values using group mean

The columns H, e, and moid have a very small fraction of their values missing. We'll fill in the missing values based on their condition code and neo group. This is better than imputing by overall sample mean.

```{r Imputing H, e and a, echo=T}
df <- df %>% group_by(neo, condition_code) %>%
  mutate(
    H = ifelse(is.na(H), mean(H, na.rm = TRUE), H),
    e = ifelse(is.na(e), mean(e, na.rm = TRUE), e),
    moid = ifelse(is.na(moid), mean(moid, na.rm = TRUE), moid)
  ) %>% ungroup()
```


### Impute using Regression

#### One hot encoding

We first need to convert the categorical columns into separate value columns using one hot encoding.

```{r Impute_using_regression One hot encoding, echo=T}
df <- data.frame(dummyVars(" ~ .", data = df) %>% predict(df))
sprintf("Number of columns: %d", ncol(df))
```

#### Pairwise Column Correlation

Now we can calculate pairwise column correlation.

```{r Impute_using_regression Finding pairwise correlation between columns, echo=T}
cor_matrix <- cor(df, use = "pairwise.complete.obs")
corrplot(cor_matrix, method = "color")
```

Observations:

1. **neoY** and **neoN** are entirely negatively correlated, which is expected. They come from the same binary column.

2. **H** seems to be somewhat correlated with both **neo** columns.

3. There are other weaker correlations.

From these observations, we think that it's better not to use the **neo** columns when doing regression.

#### Creating regression models

We'll need two regression models for imputing diameter and albedo.

```{r Impute_using_regression Creating regression model for diameter, echo=T}
diameter_model <- lm(diameter ~ H + a + e + moid + condition_code0 + 
                       condition_code2 +  condition_code6 + condition_code7 + 
                       condition_code8,
                     data = df[!is.na(df$diameter), ])

summary(diameter_model)
```

Here, we have kept only the parameters that are statistically significant at $\alpha=0.01$. The rest have been removed from the linear regression model. 

In the same way, we'll create a model for albedo as well.

```{r Impute_using_regression Creating regression model for albedo, echo=T}
albedo_model <- lm(albedo ~ H + a + e + moid + condition_code0 + 
                     condition_code1 +  condition_code2 + condition_code3 + 
                     condition_code4 +  condition_code5 + condition_code6 + 
                     condition_code7 +  condition_code8,
                     data = df[!is.na(df$albedo), ])

summary(albedo_model)
```

Both of our models have a p-value of less than $2^{-16}$. Which means, they are very good at predicting the values of diameter and albedo respectively. Now we use them to fill in the missing values

```{r Impute_using_regression filling missing values, echo=T}
missing_values <- is.na(df$diameter)
impute_data <- df[missing_values, ]
imputed_values <- predict(diameter_model, newdata = impute_data)
df$diameter[missing_values] <- imputed_values

missing_values <- is.na(df$albedo)
impute_data <- df[missing_values, ]
imputed_values <- predict(albedo_model, newdata = impute_data)
df$albedo[missing_values] <- imputed_values
```

## Custom Columns

### Distance From Earth

### Asteroid Value

### Feasibility Score

# Exploratory Data Analysis

# Conclusion

# References

