---
title: "Asteroid Mining Feasibility Analysis"
author: "Shakleen Ishfar, Eugene Ayonga, Selenge Tulga, KT Wirth"
date: "2023-11-14"
output: 
  pdf_document:
    number_sections: true
bibliography: references.bib
csl: ieee.csl
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(dev = "png",
                      dpi = 300,
                      echo = FALSE,
                      cache = TRUE)

library(ggplot2)
library(dplyr)
library(MASS)
library(corrplot)
library(caret)
library(DescTools)
```

# Introduction

Our modern world relies on natural resources like iron, copper, gold, and nickel, which form the foundation of our civilization. Unfortunately, excessive mining is harming the environment. Looking to the future, space exploration has become more affordable, opening up the possibility of tapping into asteroids for resources.

Asteroids, such as the relatively small metallic ones like Freakazoid, contain billions of dollars' worth of precious metals, even with diameters less than 1,000 meters. On a grander scale, asteroids like 16-Psyche could sustain the world's iron and nickel needs for millions of years.

![An illustration of the solar system showing the two asteroid belts. Image taken from Kurzgesagt](.\images\asteroid-belt.png)

Efficiently mining asteroids requires the development of sustainable and affordable space-grade technology. To achieve this, we must also identify which asteroids to mine and why. This project focuses on addressing the latter part of the challenge. Using statistical methods and techniques, we aim to determine which asteroids can and should be mined. Our inspiration comes from the insightful Kurzgesagt YouTube video titled "Unlimited Resources From Space – Asteroid Mining." [@Kurzgesagt2020]


# Dataset

To carry out this study we use the data pulled from NASA’s Jet Propulsion Laboratory 
(JPL), available in Kaggle. (@OpenAsteroidDataBasu2019)

```{r Loading dataset}
df <- read.csv("Asteroid_Updated.csv")

sprintf("Dataset has %d rows and %d columns", nrow(df), ncol(df))
```

The data set is quite large with nearly 1 million rows of data and 31 different columns. 

## Column Description

Let us first introduce the different attributes relevant for our study. Relevant column names from the dataset are enclosed in paranethesis after the name of the attribute.

### Semi Major Axis (a)

The semi-major axis of an asteroid is the average orbital distance from the Sun. It is half of the major axis, which is the total distance between the closest and farthest points of the asteroid’s orbit, also known as the perihelion (q) and aphelion (ad). The semi-major axis is often measured in astronomical units (AU), with 1 AU defined as the mean Earth-Sun distance. [@NASAOrbitsKeplersLaws2023]

```{r Column_Description semi major axis, echo=F}
print("Distribution of values for semi-major axis")
summary(df$a)
```

### Eccentricity (e)

The eccentricity of an asteroid is a measure of how much its orbit deviates from a perfect circle. Orbital shapes can be defined based on eccentricity value. [@WikipediaOrbitalEccentricity2023]

1. Circular orbit: $e=0$

2. Elliptic orbit: $0 < e < 1$

3. Parabolic trajectory: $e = 1$

4. Hyperbolic trajectory: $e > 1$

```{r Column_Description eccentricity, echo=F}
print("Distribution of values for eccentricity")
summary(df$e)
```

```{r Column_Description Distribution of Orbital shape, echo=F}
define_orbit <- function(e) {
  if (e < 1e-6) {
    return("Circular")
  } else if (0 < e & e < 1) {
    return("Elliptical")
  } else if (e > 1) {
    return("Hyperbolic")
  }
  return("Parabolic")
}

table(sapply(df$e, define_orbit))
```

### Geometric Albedo (albedo)

In astronomy, the geometric albedo of a celestial body is the ratio of its actual brightness as seen from the light source (i.e., at zero phase angle) to that of an idealized flat, fully reflecting, diffusively scattering (Lambertian) disk with the same cross-section. Albedo is measured on a scale of zero to one, zero representing a surface that reflects no light, and one representing an object that reflects all incoming light. [@WikipediaGeometricAlbedo2023]

```{r Column_Description Geometric Albedo, echo=F}
print("Distribution of values for eccentricity")
summary(df$albedo)
```

### Absolute Magnitude Parameter (H)

Stands for absolute magnitude parameter, denotes the brightness of an asteroid. It is defined as the apparent magnitude the asteroid would have if it were observed from the Sun at a distance of 1 Astronomical Unit (AU). This parameter is used in the calculation of an asteroid’s size. The size of an asteroid can be estimated from its absolute magnitude (H) and an assumed geometric albedo. [@NASACNEOSAsteroidSizeEstimator2023]

```{r Column_Description Absolute Magnitude Paramter}
print("Distribution of values for absolute magnitude parameter")
summary(df$H)
```

### Orbital Condition Code (condition_code)

Stands for orbital condition code, also known as the U uncertainty parameter. Values range from 0 to 9 on the logarithmic scale indicating how well an object's orbit is known. A value of 0 indicates a well-determined orbit, while a value of 9 indicates that there are insufficient observations for long-term orbit prediction. [@NASATrajectoryBrowserUserGuide2023]

Condition Code | Orbit Longitude runoff
------- | -------
0      | < 1.0 arc seconds
1      | < 4.4 arc seconds
2      | < 19.6 arc seconds
3      | < 1.4 arc minutes
4      | < 6.4 arc minutes
5      | < 28.2 arc minutes
6      | < 2.1 degrees
7      | < 9.2 degrees
8      | < 40.7 degrees
9      | > 40.7 degrees

### Near Earth Objects (NEO)

The value of 1 means the object is near earth, otherwise its 0. There are 4 types of neos. [@NASACNEOSNEOGroups2023]

| Type    | Semi-major Axis (AU) | Aphelion Distance (AU) |
| ------- | -------------------- | ---------------------- |
| Atiras  | < 1.1                | < 1.033                |
| Atens   | < 1.1                | \> 1.033               |
| Apollos | \> 1.1               | < 1.307                |
| Amors   | \> 1.1               | \> 1.307               |

![Orbital diagram showing the different types of NEO asteroids](.\images\neo_orbital_paths.png)

### Minimum Orbit Intersection Distance (moid)

It is a measure used in astronomy to assess potential close approaches and collision risks between astronomical objects. [@WikipediaMinimumOrbitIntersectionDistance2023]

MOID is important to consider for asteroid mining because:

* A lower MOID indicates a closer approach to Earth, potentially reducing the cost and travel time for mining missions.

* Consider the frequency and duration of close approaches for efficient mission planning.

* Smaller objects may have significantly lower MOIDs, making them more accessible.

# Data Processing

Before moving forward with our analysis, we first need to process the dataset.

## Attribute Selection

The dataset contains 31 columns, all of which we don't need. So, we first select the columns we need and discard the rest.

```{r Attribute_Selection, echo=T}
df <- df[c("a", "e", "moid", "neo", "condition_code", "UB", "BV", "IR", "G", "H",
           "albedo", "diameter", "per", "n", "ad", "q", "ma")]
sprintf("Number of columns in dataset: %d", ncol(df))
```

The dataset contains many null values across it's columns. We have to fill in the
missing values as well as we can. Let's first see what percentage of the columns
are missing.

```{r Imputation Missing value percentage for each column, echo=T}
missing_percentage <- colMeans(is.na(df)) * 100
sorted_missing <- sort(missing_percentage, decreasing = TRUE)

formatted_missing <- sprintf("%2.6f%%", sorted_missing)

result_df <- data.frame(Column = names(sorted_missing), 
                        MissingPercentage = formatted_missing)
print(result_df)
```

Observations:

* albedo, and diameter have over 80\% of missing values. We can use regression to fill in these values as best as we can.

* H, e, and a has very few missing values. We can impute with mean.

* condition\_code and neo has no missing values.

## Discard

### Columns

As nearly all the values are missing in G, UB, BV, and IR. We'll be dropping these columns and won't be using them in our study.

```{r Discarding Columns, echo=T}
df <- df[c("a", "e", "moid", "neo", "condition_code", "H", "albedo", "diameter", 
           "per", "n", "ad", "q", "ma")]
sprintf("Number of columns in dataset: %d", ncol(df))
```

### Rows

The column condition code has some values that aren't acceptable. Because we don't know what those values should be, it's easier to just drop them.

```{r Discarding Rows, echo=T}
before <- nrow(df)
acceptable_values <- c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
df <- df %>% filter(condition_code %in% acceptable_values)
sprintf("Dropped %d rows", before - nrow(df))
```

## Imputation

### Impute numerical values using group mean

The columns H, e, n, ma, and moid have a very small fraction of their values missing. We'll fill in the missing values based on their condition code and neo group. This is better than imputing by overall sample mean.

```{r Imputing H, e and a, echo=T}
df <- df %>% group_by(neo, condition_code) %>%
  mutate(
    H = ifelse(is.na(H), mean(H, na.rm = TRUE), H),
    e = ifelse(is.na(e), mean(e, na.rm = TRUE), e),
    moid = ifelse(is.na(moid), mean(moid, na.rm = TRUE), moid),
    ma = ifelse(is.na(ma), mean(ma, na.rm = TRUE), ma),
    ad = ifelse(is.na(ad), mean(ad, na.rm = TRUE), ad),
    q = ifelse(is.na(q), mean(q, na.rm = TRUE), q)
  ) %>% ungroup()
```


### Impute using Regression

#### One hot encoding

We first need to convert the categorical columns into separate value columns using one hot encoding.

```{r Impute_using_regression One hot encoding, echo=T}
df_encoded <- data.frame(dummyVars(" ~ .", data = df) %>% predict(df))
sprintf("Number of columns: %d", ncol(df_encoded))
```

#### Pairwise Column Correlation

Now we can calculate pairwise column correlation.

```{r Impute_using_regression Finding pairwise correlation between columns, echo=T}
cor_matrix <- cor(df_encoded, use = "pairwise.complete.obs")
corrplot(cor_matrix, method = "color")
```

Observations:

1. **neoY** and **neoN** are entirely negatively correlated, which is expected. They come from the same binary column.

2. **H** seems to be somewhat correlated with both **neo** columns.

3. **per** and **ad** are strongly correlated with **a** and with each other.

4. **q** is strongly correlated with **moid**.

From these observations, we think that it's better not to use the **neo**, **per**, **ad**, and **q** columns 
when doing regression.

#### Creating regression models

We'll need two regression models for imputing diameter and albedo.

```{r Impute_using_regression Creating regression model for diameter, echo=T}
diameter_model <- lm(diameter ~ H + a + e + moid + condition_code0 + 
                       condition_code2 +  condition_code6 + condition_code7 + 
                       condition_code8,
                     data = df_encoded[!is.na(df_encoded$diameter), ])

summary(diameter_model)
```

Here, we have kept only the parameters that are statistically significant at $\alpha=0.01$. The rest have been removed from the linear regression model. 

In the same way, we'll create a model for albedo as well.

```{r Impute_using_regression Creating regression model for albedo, echo=T}
albedo_model <- lm(albedo ~ H + a + e + moid + condition_code0 + 
                     condition_code1 +  condition_code2 + condition_code3 + 
                     condition_code4 +  condition_code5 + condition_code6 + 
                     condition_code7 +  condition_code8,
                     data = df_encoded[!is.na(df_encoded$albedo), ])

summary(albedo_model)
```

Both of our models have a p-value of less than $2^{-16}$. Which means, they are very good at predicting the values of diameter and albedo respectively. Now we use them to fill in the missing values

```{r Impute_using_regression filling missing values, echo=T}
missing_values <- is.na(df$diameter)
impute_data <- df_encoded[missing_values, ]
imputed_values <- predict(diameter_model, newdata = impute_data)
df$diameter[missing_values] <- imputed_values

missing_values <- is.na(df$albedo)
impute_data <- df_encoded[missing_values, ]
imputed_values <- predict(albedo_model, newdata = impute_data)
df$albedo[missing_values] <- imputed_values
```

## Custom Columns

### Distance From Earth

The distance from earth (d) can be calculated using semi-major axis (a) and eccentricity (e). The formula is as follows

$$
d = a \times (1 - e)
$$

```{r Custom_Columns Distance from Earth, echo=T}
df$d <- df$a * (1 - df$e)
summary(df$d)
```

### Material Group

Based on geometric albedo, we can approximately guess what type an asteroid is.

| Asteroid Type | Albedo Range | Major Components                                |
| ------------- | ------------ | ----------------------------------------------- |
| C-type        | 0.03 - 0.10  | Carbon, silicates, water ice, organic compounds |
| M-type        | 0.10 - 0.30  | Nickel-iron, iron sulfide                       |
| S-type        | 0.10 - 0.25  | Silicates, iron-nickel                          |

Based on this, we can say that asteroids are mostly of two material types: Carbonaceous or Metalic. C-type is carbonaceous while others are metallic.


```{r Column_Description Material Constitution, echo=F}
define_material <- function(albedo) {
  if (albedo < 0.10) {
    return("carbonaceous")
  } 
  return("metallic")
}

df$material <- sapply(df$albedo, define_material)
table(df$material)
```

### NEO Type

In this section, we create a column to represent the 4 NEO types.

```{r Custom_Column NEO types, echo=T}
define_neo_type <- function(a, ad) {
  ifelse(a < 1.1,
         ifelse(ad < 1.033, "Atiras", "Atens"),
         ifelse(ad < 1.307, "Apollos", "Amors"))
}

df <- df %>% rowwise() %>% mutate(neo_type = define_neo_type(a, ad))
table(df$neo_type)

```

# Exploratory Data Analysis

In this section we'd like to go over the different factors that play into asteroid mining. In particular, we try to answer the following question from a feasibility stand point:

1. **Distance**: It's easier to mine asteroids the closer they are. On average, is the mean distance of NEO asteroids less than 1 AU?

2. **Material**: Metallic resources are more valuable and thus metallic asteroids should be sought out for mining. Does NEO asteroids have proportionately more metallic asteroids than non-NEO asteroids?

3. **Diameter difference**: There are 4 different types of NEO asteroids. Is there a significant difference between their average diameter?

4. **Value difference**: From a material value standpoint, which NEO type is the best to mine?

5. **Correlation between diameter and H**: H is often used to calculate the size of an asteroid. In cases when we don't have a reliable estimate for the diameter we'll need to use this value. In that case, is there a strong correlation between these values?

## Distance from Earth

Asteroid mining is feasible for asteroid which are close to earth. This means we want to consider only NEO or Near Earth Object asteroids for our initial mining operations. The closer an asteroid is to earth the cheaper it is for us due to lower cost in transportation. A good starting point would be to mine asteroids that are at most 1 AU from earth. This is the same distance from the earth to the sun. We want to know if all NEO asteroids are on average at most 1 AU away from earth. Meaning, our hypothesis is as follows: (Here, $\mu_d$ represents the average distance for NEO asteroids)

* Null hypothesis: $\mathbf{H_0}: \mu_d \ge 1.0$. In other words, NEO asteroids are on average more than 1 AU distance from earth.

* Alternative hypothesis: $\mathbf{H_1}: \mu_d < 1.0$. In other words, NEO asteroids are on average less than 1 AU distance from earth.

As we have a large dataset, we want to be very conservative. We want to be 99.99\% confident. Which means our significance level is $\alpha = 0.0001$.

Let's take a look at the distribution of distances of NEO asteroids:

```{r EDA distance from earth histogram, echo=T}
plot_distance_hist <- function(df, xlabel) {
  mean_d <- mean(df$d)
  median_d <- median(df$d)
  
  ggplot(df, aes(x=d)) +
    geom_histogram(bins = ceiling(log(length(df$d))) + 1) +
    geom_vline(aes(xintercept = mean_d, color = "red"), show.legend = F) +
    annotate("text", x=mean_d+0.1, y=3500, 
             label=substitute(paste(bar(x),"=",m), 
                              list(m=sprintf("%.02f", mean_d))), 
             col="red") +
    geom_vline(aes(xintercept = median_d, color = "blue"), show.legend = F) +
    annotate("text", x=median_d-0.1, y=3500, 
             label=substitute(paste(tilde(x),"=",m), 
                              list(m=sprintf("%.02f", median_d))), 
             col="blue") +
    labs(title = "Histogram of Distance from Earth",
         subtitle = "For Near Earth Object (NEO) asteroids") +
    xlab(xlabel) +
    ylab("Count") +
    theme(plot.title = element_text(hjust = 0.5),
          plot.subtitle = element_text(hjust = 0.5))
}

df_temp <- df[df$neo == 'Y', 'd']
plot_distance_hist(df_temp, "Distance from Earth (AU)")
```

The distribution of the distance appears to be left skewed. We'll make it more symmetrical shape using boxcox transformation.

```{r EDA boxcox to make distance normal shaped, echo=T}
bcl_d = boxcox(df_temp$d~1)
lambda_d = bcl_d$x[bcl_d$y == max(bcl_d$y)]
df_temp$d = (df_temp$d ^ lambda_d - 1) / lambda_d
```

Now the distribution should look much more normally distributed.

```{r EDA distance from earth histogram after boxcox, echo=F}
plot_distance_hist(df_temp, "Distance from Earth boxcox transformed")
```

Now that our data is normal, we can move forward with the hypothesis test. We'll be doing a one sample t-test. As we don't know the population variance, we can't do a z-test.

```{r EDA Distance from Earth t-test, echo=T}
t.test(x = df_temp$d, alternative = "less", conf.level = 1-0.0001, 
       mu = (1 ^ lambda_d - 1) / lambda_d)
```

The p-value is $2.2^{-16}$ which is much smaller than our level of significance. Thus, we have significant evidence to reject the null hypothesis.

```{r EDA Distance from Earth confidence interval, echo=T}
upper_bound <- (-0.05067877 * lambda_d + 1) ^ (1 / lambda_d)
sprintf("Confidence Interval in original scale: (-inf, %.4f)", upper_bound)
```

Meaning, NEO asteroids on average are at most 0.9481 AU from earth.

### Verdict

Most near earth asteroids are at most 1 AU from our planet. That's great news for asteroids mining as we don't have to spend a lot on space travel to find asteroids to mine.

## Material Value

Metals, like iron, nickel, gold, platinum, are the building block of our civilization. They are precious resources and will be highly valuable to mine from asteroids. Asteroids composed of metals are thus highly valuable. So for asteroid mining to be feasible we might want to seek out and mine metallic asteroids more than carbonaceous ones. However, most asteroids we know are carbonaceous. In accordance with out previous decision then, it doesn't make much sense to go mine asteroids that aren't NEO as most of those will be carbonaceous while being far away. We'd like to test this claim with a two-sample proportion test.

* Null Hypothesis: $\mathbf{H_0}: p_c \le p_f$ which means the proportion of metallic NEO asteroids ($p_c$) are less than or equal to the proportion of metallic non-NEO asteroids ($p_f$).

* Alternative Hypothesis: $\mathbf{H_1}: p_c > p_f$ which means the proportion of metallic NEO asteroids ($p_c$) are greater the proportion of metallic non-NEO asteroids ($p_f$).

As before, because we have a lot of samples, we want to be very confident, about 99.99\%. Meaning, our significance level is $\alpha = 0.0001$.

We begin by visually looking at the distribution of different types of asteroids.

```{r EDA Bar chart for material distribution}
df_temp <- df[c("material", "neo")]

ggplot(df_temp, aes(x=neo, fill=material)) +
  geom_bar(position="fill") +
  labs(title = "Bar Chart", subtitle = "Proportion of asteroid types") +
  xlab("Near Earth Object (NEO)") +
  ylab("Proportion") +
  theme(plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5))
```

From the bar chart, it looks like that a higher proportion of non-NEO asteroids are metallic, which aligns with the null hypothesis. Let's see if we can statistically reject it.

```{r EDA two sample proportion test for asteroid type}
# Separate data into two groups based on a condition
x_c <- nrow(df_temp[df_temp$material == "metallic" & df_temp$neo == "Y", ])
x_f <- nrow(df_temp[df_temp$material == "metallic" & df_temp$neo == "N", ])

# Count occurrences of each category in each group
n_c <- nrow(df_temp[df_temp$neo == "Y", ])
n_f <- nrow(df_temp[df_temp$neo == "N", ])

# Hypothesis test
prop.test(x = c(x_c, x_f), n = c(n_c, n_f),
          alternative = "greater", conf.level = 1-0.0001,
          correct = F)
```

Since the p-value is greater than our confidence level, we fail to reject the null hypothesis. Meaning, a greater proportion of non-NEO asteroids are metallic than NEO asteroids.

### Verdict

This test allows us to see the trade off between distance and value. It proves that we are more likely to get highly valuable asteroids when we don't limit ourselves to near earth asteroids. This is because a greater proportion of asteroids that are not NEO are metallic and these are highly desirable asteroids.

## Diameter Difference

There are 4 different types of NEOs based on semi-major axis and aphelion distance: Amors, Apollos, Atens, and Atiras. Amos is the closest to earth's orbit while Atiras is the furthest away. We want to see if the size of the asteroids vary across these 4 types. Meaning, we'd like to do a hypothesis test using ANOVA, where we check if the average diameter of asteroids is different among these 4 types of asteroids. If so, we'd like to know which NEO asteroids are on average larger from pairwise t-tests. Thus our hypothesis is as follows:

* Null Hypothesis: $\mathbf{H_0}: \mu_1 = \mu_2 = \mu_3 = \mu_4$. There is no significant difference in the average diameter of asteroids among the four types (Amors, Apollos, Atens, and Atiras).

* Alternative Hypothesis:  $\mathbf{H_1}: \text{At least one } \mu_i \text{ is different}$ There is a significant difference in the average diameter of asteroids among the four types (Amors, Apollos, Atens, and Atiras).

We're going to carry out this hypothesis test with $\alpha = 0.0001$.

<!-- Columns: diameter and neo_type -->

```{r EDA Diameter_Difference visualization, echo=T}
df_neo_dia_filter <- df[c("diameter", "neo_type")]

df_neo_dia <- df_neo_dia_filter[df_neo_dia_filter$diameter > 0, ]
```

```{r EDA Diameter_Difference Mean table, echo=T}
mean_diameters <- df_neo_dia %>%
  group_by(neo_type) %>%
  summarise(avg_diameter = mean(diameter),count = n())
print(mean_diameters)
```


```{r EDA Diameter_Difference boxplot}
 ggplot(df_neo_dia, aes(x = neo_type, y = diameter, fill = neo_type)) +
  geom_violin(trim = FALSE) +
  geom_boxplot(width = 0.2, fill = "white") +
  labs(title = "Asteroid Diameters by NEO Type",
       x = "NEO Type",
       y = "Diameter")

```
```{r EDA Diameters Identifing outliers}
neo_type_outliers <- df_neo_dia %>%
  group_by(neo_type) %>%
  mutate(outliers_iqr = diameter < quantile(diameter, 0.25) - 1.5 * IQR(diameter) | 
                         diameter > quantile(diameter, 0.75) + 1.5 * IQR(diameter))
print(nrow(neo_type_outliers))

```

```{r EDA Diameters Removing outliers}
df_neo_dia <- df_neo_dia %>%
  group_by(neo_type) %>%
  mutate(
    q1 = quantile(diameter, 0.25),
    q3 = quantile(diameter, 0.75),
    iqr = q3 - q1,
    lower_bound = q1 - 1.5 * iqr,
    upper_bound = q3 + 1.5 * iqr
  ) %>%
  ungroup()

# Filter out the outliers
df_neo_dia_no_outliers <- df_neo_dia %>%
  filter(diameter >= lower_bound & diameter <= upper_bound)

print(nrow(df_neo_dia_no_outliers))
```
```{r EDA Diameters Mean diameter of each neo}
mean_diameters <- df_neo_dia_no_outliers %>%
  group_by(neo_type) %>%
  summarise(avg_diameter = mean(diameter),count = n())
print(mean_diameters)
```
```{r Diameter_Difference without outliers boxplot}
 ggplot(df_neo_dia_no_outliers, aes(x = neo_type, y = diameter, fill = neo_type)) +
  geom_violin(trim = FALSE) +
  geom_boxplot(width = 0.2, fill = "white") +
  labs(title = "Asteroid Diameters by NEO Type",
       x = "NEO Type",
       y = "Diameter")
```

```{r EDA Diameter_Difference One-way ANOVA, echo=T}

anova_result <- aov(diameter~ neo_type, data = df_neo_dia_no_outliers)
summary(anova_result)

```
Given the p-value of 2e-16 and a significance level of 0.0001. We can reject the null hypothesis. Therefore, there is sufficient evidence to conclude that there is a significant difference in the average diameter of asteroids among the four types (Amors, Apollos, Atens, and Atiras).


```{r EDA Diameter_Difference Pair t-test, echo=T}
# Perform Tukey's HSD test
tukey_result <- TukeyHSD(anova_result)

print(tukey_result)

plot(tukey_result, las = 1)

```
There are significant differences in mean diameters between Apollos and both Atens and Atiras, with Apollos having smaller mean diameters.
Atens and Atiras do not show a significant difference in mean diameters.
For Atens vs. Apollos and Atiras vs. Apollos, there is no significant difference in mean diameters.

### Verdict

Amor's diameter is more bigger than other types and good news is Amors is the closest type from our planet. Also, count of Amor is significantly higher than other types. 

## Value Difference

Among the 4 different types of NEO asteroids, we want to determine which type has most percentage of metallic asteroids. The more metallic asteroid, the better our chance of mining precious materials. For this, we're going to a chisqaure test of independence. We want to find distinctions in proportions among the different asteroid types and then find which one has the highest. Our hypothesis is as follows:

* Null Hypothesis: TODO

* Alternative Hypothesis: TODO

We're going to carry out this hypothesis test with $\alpha = 0.0001$.

<!-- Columns: material and neo_type -->

```{r EDA Value_Difference visualization, echo=T}
# TODO: Visualization
```

<!-- TODO: What can be seen and inferred from the chart -->

<!-- TODO: If transformation needs to be done, explain what transformation and why -->

```{r EDA Value_Difference transformation, echo=T}
# TODO: Transformation (if required)
```


<!-- TODO: Hypothesis test -->

```{r EDA Value_Difference chisqaure test of independence, echo=T}
# TODO: Hypothesis testing (chisqaure test of independence)
```

<!-- TODO: Reject / fail to reject null hypothesis -->

<!-- TODO: If reject, then say which has the highest proportion -->

### Verdict

<!-- TODO: What does this mean for the question we asked? -->


## Correlation between H and Diameter

In many cases, we don't have reliable estimates for asteroid diameters. In our dataset almost 80\% of the diameter values are null. In these cases, we might need to use an alternative attribute to measure the size of an asteroid. This could be H, as it is used quite often to determine asteroid size at NASA. So, we want to know if H is correlated with the diameter value. 

```{r EDA Scatterplot}
df_temp <- df[df$diameter >= 0, c("diameter", "H")]

ggplot(df_temp, aes(x=diameter, y=H)) +
    geom_point() +
    labs(title = "Scatter Plot",
         subtitle = "Between H and diameter") +
    xlab("Diameter") +
    ylab("Absolute Magnitude Parameter (H)") +
    theme(plot.title = element_text(hjust = 0.5),
          plot.subtitle = element_text(hjust = 0.5))

```

From the scatter plot, it looks like there is an inverse relationship between H and diameter. As diameter increases, H decreases. Let's see what the pearson's and spearman's correlation says.

```{r EDA Correlation}
sprintf("Correlation according to pearson is %.3f", 
        cor(df_temp$diameter, df_temp$H, method = "pearson"))
sprintf("Correlation according to pearson is %.3f", 
        cor(df_temp$diameter, df_temp$H, method = "spearman"))
```

In both cases, we can see that there is somewhat of a negative correlation. However, we need to know if this is statistically significant. We'll do a pearson's and spearman's correlation test. Here our hypothesis are as follows:

* Null Hypothesis: $\mathbf{H_0}: \rho = 0$ meaning that diameter and H are independent.

* Alternative Hypothesis: $\mathbf{H_1}: \rho \ne 0$ meaning that diameter and H are correlated.

We'll do this test with a 99.99\% confidence level.

```{r EDA Pearsons Correlation test}
cor.test(df_temp$diameter, df_temp$H, method = "pearson", conf.level = 1-0.0001,
         exact = F)
```

As the p-value is less than our significance level, we can reject the null hypothesis. Meaning, diameter and H aren't independent. As there are a lot of outliers, let's do a spearman's correlation test with the same parameters as well.

```{r EDA Spearmans Correlation test}
cor.test(df_temp$diameter, df_temp$H, method = "spearman", conf.level = 1-0.0001,
         exact = F)
```

The results are the same for spearman as well. 

### Verdict

So when we don't know the diameter value, we can somewhat use H as a replacement. The smaller the H value is the larger the asteroid will be as the two attributes are inversely related

# Conclusion

We can see that most asteroids that are near us are less than 1 AU away from earth. Amongst them Amor has the greatest proportion of metallic asteroids and also has the largest asteroids as well. For asteroid minign to be feasible, we should start with Amor Near Earth Asteroids. As they are the closest and offers the most value.

# References

